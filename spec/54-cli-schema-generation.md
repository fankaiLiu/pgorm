# Schema 生成（DDL Generation）设计与计划

状态：Draft
相关代码：`crates/pgorm-cli/` / `crates/pgorm-derive`
最后更新：2026-02-05

## 背景

当前 `pgorm` 的开发流程是"Database First"：

1. 用户在数据库中创建表
2. 用户手写 Rust Model
3. 使用 `pgorm-check` 验证 Model 与数据库 Schema 一致

这种方式在以下场景存在痛点：

1. **新项目启动**：需要同时维护 SQL 迁移文件和 Rust Model
2. **Schema 变更**：修改 Model 后需要手写对应的 ALTER TABLE
3. **团队协作**：Model 和 Schema 容易不同步

Schema 生成功能可以：
- 从 Model 生成 DDL（`CREATE TABLE`）
- 比较 Model 与数据库，生成差异迁移（`ALTER TABLE`）
- 提供双向同步能力

## 目标 / 非目标

### 目标

1. **DDL 生成**：从 Rust Model 生成 `CREATE TABLE` 语句。
2. **Schema Diff**：比较 Model 与数据库，输出差异。
3. **迁移生成**：基于 Diff 生成 `ALTER TABLE` 迁移文件。
4. **CLI 集成**：通过 `pgorm schema` 命令访问功能。
5. **类型映射**：Rust 类型到 PostgreSQL 类型的明确映射。

### 非目标

- 完全自动化的迁移应用（用户应审核生成的 SQL）。
- 复杂的数据迁移（如拆分列、合并表）。
- 支持所有 PostgreSQL 特性（如分区表、继承）。
- 替代专业迁移工具（如 `refinery`、`sqlx-cli`）。

## 方案

### 1) Model 元数据增强

扩展 `#[derive(Model)]` 宏，支持更多 Schema 信息：

```rust,ignore
#[derive(Model)]
#[orm(table = "users")]
pub struct User {
    #[orm(primary_key, auto_increment)]
    pub id: i64,

    #[orm(unique)]
    pub email: String,

    #[orm(column = "full_name", length = 100)]
    pub name: String,

    #[orm(nullable = false, default = "'active'")]
    pub status: String,

    #[orm(index)]
    pub created_at: DateTime<Utc>,

    #[orm(index = "idx_users_status_created")]
    pub updated_at: DateTime<Utc>,

    #[orm(foreign_key = "roles.id", on_delete = "CASCADE")]
    pub role_id: i64,
}
```

### 2) 类型映射规则

| Rust 类型 | PostgreSQL 类型 | 说明 |
|-----------|----------------|------|
| `i16` | `SMALLINT` | |
| `i32` | `INTEGER` | |
| `i64` | `BIGINT` | |
| `f32` | `REAL` | |
| `f64` | `DOUBLE PRECISION` | |
| `bool` | `BOOLEAN` | |
| `String` | `TEXT` | 默认 |
| `String` + `length = N` | `VARCHAR(N)` | |
| `Vec<u8>` | `BYTEA` | |
| `Uuid` | `UUID` | |
| `DateTime<Utc>` | `TIMESTAMPTZ` | |
| `NaiveDateTime` | `TIMESTAMP` | |
| `NaiveDate` | `DATE` | |
| `NaiveTime` | `TIME` | |
| `Decimal` | `NUMERIC` | |
| `Decimal` + `precision` | `NUMERIC(p, s)` | |
| `IpAddr` | `INET` | |
| `serde_json::Value` | `JSONB` | |
| `Json<T>` | `JSONB` | |
| `Option<T>` | `T NULL` | |
| `Vec<T>` | `T[]` | |

### 3) CLI 命令

```bash
# 从 Model 生成 DDL
pgorm schema generate --output schema.sql

# 比较 Model 与数据库
pgorm schema diff --database-url $DATABASE_URL

# 生成迁移文件
pgorm schema migrate --output migrations/

# 验证 Model 与数据库一致
pgorm schema check --database-url $DATABASE_URL
```

### 4) Schema Diff 算法

```rust,ignore
pub struct SchemaDiff {
    pub tables_to_create: Vec<TableDef>,
    pub tables_to_drop: Vec<String>,
    pub columns_to_add: Vec<ColumnChange>,
    pub columns_to_drop: Vec<ColumnChange>,
    pub columns_to_alter: Vec<ColumnChange>,
    pub indexes_to_create: Vec<IndexDef>,
    pub indexes_to_drop: Vec<String>,
    pub constraints_to_add: Vec<ConstraintDef>,
    pub constraints_to_drop: Vec<String>,
}

impl SchemaDiff {
    pub fn compute(models: &[ModelMeta], database: &DatabaseSchema) -> Self;
    pub fn to_sql(&self) -> String;
    pub fn is_empty(&self) -> bool;
}
```

## 使用示例

### A) 生成 DDL

```rust,ignore
// models.rs
#[derive(Model)]
#[orm(table = "users")]
pub struct User {
    #[orm(primary_key, auto_increment)]
    pub id: i64,

    #[orm(unique, length = 255)]
    pub email: String,

    #[orm(nullable = false)]
    pub name: String,

    #[orm(default = "NOW()")]
    pub created_at: DateTime<Utc>,
}

#[derive(Model)]
#[orm(table = "posts")]
pub struct Post {
    #[orm(primary_key, auto_increment)]
    pub id: i64,

    #[orm(foreign_key = "users.id", on_delete = "CASCADE")]
    pub user_id: i64,

    pub title: String,

    pub content: String,

    #[orm(index)]
    pub published_at: Option<DateTime<Utc>>,
}
```

```bash
$ pgorm schema generate

-- Generated by pgorm schema generate
-- Models: users, posts

CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE posts (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    published_at TIMESTAMPTZ
);

CREATE INDEX idx_posts_published_at ON posts(published_at);
```

### B) Schema Diff

```bash
$ pgorm schema diff --database-url $DATABASE_URL

Comparing models with database...

Tables to create:
  - comments

Columns to add:
  - users.avatar_url (TEXT)
  - posts.view_count (INTEGER DEFAULT 0)

Columns to alter:
  - users.name: TEXT -> VARCHAR(100)

Indexes to create:
  - idx_posts_user_id ON posts(user_id)

Run 'pgorm schema migrate' to generate migration files.
```

### C) 生成迁移

```bash
$ pgorm schema migrate --output migrations/

Generated: migrations/20260205120000_schema_sync.sql

-- Migration: schema_sync
-- Generated at: 2026-02-05 12:00:00

-- Add table: comments
CREATE TABLE comments (
    id BIGSERIAL PRIMARY KEY,
    post_id BIGINT NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(id),
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add column: users.avatar_url
ALTER TABLE users ADD COLUMN avatar_url TEXT;

-- Add column: posts.view_count
ALTER TABLE posts ADD COLUMN view_count INTEGER DEFAULT 0;

-- Alter column: users.name
ALTER TABLE users ALTER COLUMN name TYPE VARCHAR(100);

-- Add index: idx_posts_user_id
CREATE INDEX idx_posts_user_id ON posts(user_id);
```

### D) 程序化 API

```rust,ignore
use pgorm_cli::schema::{SchemaDiff, ModelMeta, DatabaseSchema};

// 获取 Model 元数据
let models = ModelMeta::from_crate("my_app")?;

// 获取数据库 Schema
let db_schema = DatabaseSchema::from_url(&database_url).await?;

// 计算差异
let diff = SchemaDiff::compute(&models, &db_schema);

if diff.is_empty() {
    println!("Schema is up to date!");
} else {
    println!("Differences found:");
    println!("{}", diff.to_sql());
}
```

## 属性参考

### 表级属性

| 属性 | 说明 | 示例 |
|------|------|------|
| `table` | 表名 | `#[orm(table = "users")]` |
| `schema` | Schema 名 | `#[orm(schema = "public")]` |

### 字段属性

| 属性 | 说明 | 示例 |
|------|------|------|
| `primary_key` | 主键 | `#[orm(primary_key)]` |
| `auto_increment` | 自增 | `#[orm(auto_increment)]` |
| `unique` | 唯一约束 | `#[orm(unique)]` |
| `nullable` | 允许 NULL | `#[orm(nullable = true)]` |
| `default` | 默认值 | `#[orm(default = "NOW()")]` |
| `length` | VARCHAR 长度 | `#[orm(length = 255)]` |
| `precision` | NUMERIC 精度 | `#[orm(precision = "10,2")]` |
| `column` | 列名 | `#[orm(column = "full_name")]` |
| `index` | 创建索引 | `#[orm(index)]` |
| `index` | 命名索引 | `#[orm(index = "idx_name")]` |
| `foreign_key` | 外键 | `#[orm(foreign_key = "users.id")]` |
| `on_delete` | 外键删除行为 | `#[orm(on_delete = "CASCADE")]` |
| `on_update` | 外键更新行为 | `#[orm(on_update = "SET NULL")]` |
| `check` | CHECK 约束 | `#[orm(check = "age >= 0")]` |

## 关键取舍

| 选项 | 优点 | 缺点 | 决策 |
|------|------|------|------|
| Code First vs DB First | 统一来源 | 不适合现有项目 | **支持双向** |
| 自动应用 vs 生成文件 | 方便 | 风险高 | **只生成文件** |
| 完整 DDL vs 增量迁移 | 简单 | 不适合演进 | **两者都支持** |

## 安全考虑

### 破坏性操作警告

生成的迁移会标记破坏性操作：

```sql
-- WARNING: This operation may cause data loss
-- DROP TABLE old_table;

-- WARNING: This column change may truncate data
-- ALTER TABLE users ALTER COLUMN name TYPE VARCHAR(50);
```

### 审核流程

1. 生成迁移文件
2. 人工审核
3. 应用迁移
4. 运行 `pgorm schema check` 验证

## 兼容性与迁移

- 新增 CLI 命令，不影响现有功能。
- 新增 derive 属性是可选的，不影响现有 Model。
- 与 `refinery` 迁移兼容（生成标准 SQL 文件）。

## 里程碑 / TODO

### M1（DDL 生成）

- [ ] 扩展 `#[derive(Model)]` 解析 Schema 属性
- [ ] `ModelMeta` 结构体
- [ ] Rust 类型到 PostgreSQL 类型映射
- [ ] `pgorm schema generate` 命令
- [ ] 单元测试

### M2（Schema Diff）

- [ ] `DatabaseSchema::from_url()` 数据库 introspection
- [ ] `SchemaDiff::compute()` 差异算法
- [ ] `pgorm schema diff` 命令
- [ ] 集成测试

### M3（迁移生成）

- [ ] 迁移文件生成
- [ ] 破坏性操作检测与警告
- [ ] `pgorm schema migrate` 命令
- [ ] `pgorm schema check` 命令

### M4（文档与示例）

- [ ] CLI 帮助文档
- [ ] 中英文用户指南
- [ ] 示例项目

## Open Questions

1. 是否支持"仅检查，不生成"模式用于 CI？（建议支持，`pgorm schema check --strict`）
2. 复合主键如何声明？（建议 `#[orm(primary_key(order = 1))]`）
3. 是否支持表注释？（建议支持，`#[orm(comment = "...")]`）
4. 生成的迁移文件命名格式？（建议 `YYYYMMDDHHMMSS_description.sql`）
