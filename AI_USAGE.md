# pgorm – AI usage guide

This document is a pragmatic cheat-sheet for using `pgorm` in code generated by LLMs (or written quickly by humans): copy-paste templates, feature selection, and common pitfalls.

If you just want to “get it working with guardrails”, use `PgClient` in `strict()` mode and keep `pgorm` default features enabled.

## Copy-paste template (recommended)

`Cargo.toml`:

```toml
[dependencies]
pgorm = "0.1.0"
tokio = { version = "1", features = ["macros", "rt-multi-thread"] }
dotenvy = "0.15"
```

`src/main.rs`:

```rust
use pgorm::prelude::*;

#[derive(Debug, FromRow, Model)]
#[orm(table = "users")]
struct User {
    #[orm(id)]
    id: i64,
    username: String,
}

#[tokio::main]
async fn main() -> pgorm::OrmResult<()> {
    dotenvy::dotenv().ok();
    let database_url =
        std::env::var("DATABASE_URL").map_err(|_| pgorm::OrmError::Connection("DATABASE_URL is not set".to_string()))?;

    let pool = create_pool(&database_url)?;
    let client = pool.get().await?;

    // Strict = fail-fast when SQL references unknown tables/columns.
    let pg = PgClient::with_config(client, PgClientConfig::new().strict());

    let user: User = query("SELECT id, username FROM users WHERE id = $1")
        .bind(1_i64)
        .fetch_one_as(&pg)
        .await?;

    println!("{user:?}");
    Ok(())
}
```

## Feature selection (avoid “missing type / missing macro” errors)

Default features are `pool`, `derive`, `check` (recommended for most apps).

If you intentionally want “just SQL builder + GenericClient trait”:

```toml
pgorm = { version = "0.1.0", default-features = false }
```

If you disable default features but still want macros:

```toml
pgorm = { version = "0.1.0", default-features = false, features = ["derive"] }
```

If you disable default features but still want pool helpers:

```toml
pgorm = { version = "0.1.0", default-features = false, features = ["pool"] }
```

## Which API to use

- **Hand-written SQL**: `query("... $1 ...").bind(x).fetch_* / execute`
- **Dynamic SQL** (auto `$n` placeholders): `sql("...").push("...").push_bind(x)`
- **Transactions**: accept `&impl GenericClient` in your repository functions; use `pgorm::transaction!(&mut client, tx, { ... })` for commit/rollback.
- **Guardrails**:
  - `PgClient` = recommended unified wrapper (monitoring + optional SQL checking)
  - `CheckedClient` = simpler wrapper that only does SQL checking

## Derive macros: attribute cheat-sheet

### `#[derive(FromRow)]`

Field attribute:

- `#[orm(column = "db_column")]`

### `#[derive(Model)]` / `#[derive(ViewModel)]`

Struct attributes:

- `#[orm(table = "table_name")]` (required)
- `#[orm(join(table = "...", on = "...", type = "inner|left|right|full|cross"))]` (optional, repeatable)
- `#[orm(has_many(ChildType, foreign_key = "child_fk", as = "children"))]` (optional, repeatable)
- `#[orm(belongs_to(ParentType, foreign_key = "parent_fk", as = "parent"))]` (optional, repeatable)

Field attributes:

- `#[orm(id)]` (optional)
- `#[orm(column = "db_column")]` (optional)
- `#[orm(table = "other_table")]` (optional; used for join/view models)

### `#[derive(InsertModel)]`

Struct attributes:

- `#[orm(table = "table_name")]` (required)
- `#[orm(returning = "TypePath")]` (optional; enables `insert_returning`)
- Conflict handling (Postgres `ON CONFLICT`):
  - `#[orm(conflict_target = "col1,col2")]` (optional)
  - `#[orm(conflict_constraint = "constraint_name")]` (optional)
  - `#[orm(conflict_update = "col1,col2")]` (optional; update-set list)
- Multi-table write graph (advanced): see `docs/design/multi-table-writes-final.md`

Field attributes:

- `#[orm(id)]` (optional)
- `#[orm(skip_insert)]` (optional)
- `#[orm(default)]` (optional; generates `DEFAULT`)
- `#[orm(auto_now_add)]` (optional; set `NOW()` on insert)
- `#[orm(column = "db_column")]` / `#[orm(table = "table_name")]` (optional)

### `#[derive(UpdateModel)]`

Struct attributes:

- `#[orm(table = "table_name")]` (required)
- One of:
  - `#[orm(id_column = "id")]` (explicit PK column), or
  - `#[orm(model = "TypePath")]` (derive PK column from model), or
  - `#[orm(returning = "TypePath")]` where `TypePath::ID` exists
- `#[orm(returning = "TypePath")]` (optional; enables `update_by_id_returning`)
- Multi-table write graph (advanced): see `docs/design/multi-table-writes-final.md`

Field attributes:

- `#[orm(skip_update)]`
- `#[orm(default)]` (sets `DEFAULT`)
- `#[orm(auto_now)]` (sets `NOW()`)
- `#[orm(column = "db_column")]` / `#[orm(table = "table_name")]` (optional)

## Common pitfalls (and fixes)

- **“cannot find derive macro `Model` in this scope”**: you disabled `pgorm` default features; enable `features = ["derive"]` (or keep defaults).
- **SQL placeholder mistakes**: `query()` expects you to write `$1, $2, ...`; if you need to conditionally add filters, use `sql()` + `push_bind()` instead.
- **“Not found” surprises**: `query_one`/`fetch_one_*` returns `OrmError::NotFound` when 0 rows match; use `query_opt`/`fetch_opt_*` if 0 rows is ok.
