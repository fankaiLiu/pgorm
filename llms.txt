pgorm (Rust) â€” Postgres-only ORM (SQL-first)

Purpose
- pgorm keeps SQL explicit (you write SQL; pgorm helps bind params, map rows, and add guardrails).
- It supports runtime SQL checking/linting against registered model schemas (useful for AI-generated SQL).

Start here
- README.md (overview + quick start)
- AI_USAGE.md (copy/paste templates + feature flags + macro attribute cheat-sheet)

Core APIs
- query("... $1 ...").bind(v).fetch_* / execute
  - Use when you already have a full SQL string and you manage $1, $2, ...
- sql("...").push(" ... ").push_bind(v)
  - Use for dynamic SQL; placeholders ($n) are generated automatically
- GenericClient
  - Most APIs take &impl GenericClient so the same code works with a plain client or a transaction
- pgorm::transaction!(&mut client, tx, { ... })
  - Runs a block inside a transaction; commits on Ok and rolls back on Err

Guardrails (recommended for AI-generated SQL)
- PgClient (feature: check)
  - Unified wrapper: SQL checking + monitoring/stats + configurable timeouts/logging
  - Tip: PgClientConfig::new().strict() to fail fast on unknown tables/columns
- CheckedClient (feature: check)
  - Lightweight wrapper that only does schema-based SQL checking

Feature flags (pgorm crate)
- default = ["pool", "derive", "check"] (recommended for most apps)
- pool: deadpool-postgres helpers (create_pool)
- derive: proc-macros (FromRow, Model, InsertModel, UpdateModel, ViewModel)
- check: SQL parsing/linting + schema checking + PgClient/CheckedClient
- migrate: refinery migrations

Derive macros (high level)
- FromRow: map tokio_postgres::Row -> struct (field attr: #[orm(column = "...")])
- Model/ViewModel: table metadata + select/delete helpers; supports joins and simple relations
- InsertModel/UpdateModel: generate INSERT/UPDATE helpers; advanced multi-table graph writes exist (see docs/design/)

Common pitfalls
- If you disabled default features and want derive macros, enable features = ["derive"].
- query() expects you to write $1, $2...; use sql() for dynamic composition.
