use crate::analyze::{
    SelectColumn, extract_param_casts, extract_param_numbers, extract_select_columns,
};
use crate::config::{PackageConfig, ProjectConfig};
use crate::queries::{QueryDef, QueryFile, QueryKind};
use crate::type_mapper::TypeMapper;
use pgorm_check::DbSchema;
use std::collections::{HashMap, HashSet};
use std::path::PathBuf;

type TableResolution = (Vec<(String, String)>, HashMap<String, (String, String)>);

#[derive(Debug, Clone)]
pub struct GeneratedFile {
    pub path: PathBuf,
    pub content: String,
}

pub fn generate_package(
    project: &ProjectConfig,
    pkg: &PackageConfig,
    schema: &DbSchema,
    query_files: &[QueryFile],
) -> anyhow::Result<Vec<GeneratedFile>> {
    let out_dir = project.resolve_path(&pkg.out);
    let type_mapper = TypeMapper::new(pkg.types.clone());

    let mut files: Vec<GeneratedFile> = Vec::new();

    // mod.rs
    let mod_rs = generate_mod_rs(pkg, query_files)?;
    files.push(GeneratedFile {
        path: out_dir.join("mod.rs"),
        content: mod_rs,
    });

    for qf in query_files {
        let module_rs = generate_module_rs(pkg, schema, &type_mapper, qf)?;
        files.push(GeneratedFile {
            path: out_dir.join(format!("{}.rs", qf.module)),
            content: module_rs,
        });
    }

    Ok(files)
}

fn generate_mod_rs(pkg: &PackageConfig, query_files: &[QueryFile]) -> anyhow::Result<String> {
    let mut module_names: Vec<&str> = query_files.iter().map(|f| f.module.as_str()).collect();
    module_names.sort();
    module_names.dedup();

    let mut out = String::new();
    out.push_str("// @generated by pgorm (pgorm-cli)\n");

    if pkg.codegen.emit_queries_struct {
        out.push_str("\nuse pgorm::GenericClient;\n\n");
        out.push_str("pub struct Queries<'a, C: GenericClient> {\n");
        out.push_str("    pub(crate) conn: &'a C,\n");
        out.push_str("}\n\n");
        out.push_str("impl<'a, C: GenericClient> Queries<'a, C> {\n");
        out.push_str("    pub fn new(conn: &'a C) -> Self {\n");
        out.push_str("        Self { conn }\n");
        out.push_str("    }\n");
        out.push_str("}\n");
    }

    out.push('\n');
    for m in module_names {
        out.push_str(&format!("pub mod {m};\n"));
    }

    Ok(out)
}

fn generate_module_rs(
    pkg: &PackageConfig,
    schema: &DbSchema,
    type_mapper: &TypeMapper,
    qf: &QueryFile,
) -> anyhow::Result<String> {
    let mut out = String::new();
    out.push_str("// @generated by pgorm (pgorm-cli)\n\n");

    // Ensure `FromRow` derive is resolvable when requested.
    let mut uses: Vec<String> = pkg.codegen.extra_uses.clone();
    if pkg.codegen.row_derives.iter().any(|d| d == "FromRow")
        && !uses.iter().any(|u| u == "pgorm::FromRow")
    {
        uses.push("pgorm::FromRow".to_string());
    }
    uses.sort();
    uses.dedup();
    let has_uses = !uses.is_empty();
    for u in uses {
        out.push_str(&format!("use {u};\n"));
    }
    if !pkg.codegen.emit_queries_struct {
        out.push_str("use pgorm::GenericClient;\n");
    }
    if has_uses || !pkg.codegen.emit_queries_struct {
        out.push('\n');
    }

    // Generate per-query items.
    for q in &qf.queries {
        generate_query_items(pkg, schema, type_mapper, q, &mut out)?;
        out.push('\n');
    }

    Ok(out)
}

fn generate_query_items(
    pkg: &PackageConfig,
    schema: &DbSchema,
    type_mapper: &TypeMapper,
    q: &QueryDef,
    out: &mut String,
) -> anyhow::Result<()> {
    // Constant SQL (optional)
    let const_name = format!("SQL_{}", to_shouty_snake(&q.name));
    if pkg.codegen.emit_query_constants {
        out.push_str(&format!(
            "pub const {const_name}: &str = {};\n\n",
            raw_string_literal(&q.sql)
        ));
    }

    // Params
    let params = extract_param_numbers(&q.sql)?;
    let casts = extract_param_casts(&q.sql);
    let mut param_decls: Vec<(String, String)> = Vec::new();
    for n in &params {
        let name = format!("param{n}");
        let ty = if let Some(override_ty) = pkg.overrides.param_override(&q.name, *n) {
            override_ty.to_string()
        } else if let Some(cast_ty) = casts.get(n) {
            type_mapper.map(cast_ty)
        } else {
            // MVP fallback (encourage `$n::type` or overrides).
            "String".to_string()
        };
        param_decls.push((name, ty));
    }

    // Return / Row struct
    let (ret_ty, exec_method, row_struct) = match q.kind {
        QueryKind::Exec | QueryKind::ExecRows => (
            "pgorm::OrmResult<u64>".to_string(),
            ExecMethod::Execute,
            None,
        ),
        QueryKind::One => {
            let row = build_row_struct(pkg, schema, type_mapper, q)?;
            let ty = format!("pgorm::OrmResult<{}>", row.name);
            (ty, ExecMethod::FetchOne, Some(row))
        }
        QueryKind::Opt => {
            let row = build_row_struct(pkg, schema, type_mapper, q)?;
            let ty = format!("pgorm::OrmResult<Option<{}>>", row.name);
            (ty, ExecMethod::FetchOpt, Some(row))
        }
        QueryKind::Many => {
            let row = build_row_struct(pkg, schema, type_mapper, q)?;
            let ty = format!("pgorm::OrmResult<Vec<{}>>", row.name);
            (ty, ExecMethod::FetchAll, Some(row))
        }
    };

    if let Some(row) = &row_struct {
        out.push_str(&row.render(pkg));
        out.push('\n');
    }

    // Function signature.
    let fn_name = to_snake(&q.name);
    let args = param_decls
        .iter()
        .map(|(n, t)| format!("{n}: {t}"))
        .collect::<Vec<_>>()
        .join(", ");
    let args_with_leading_comma = if args.is_empty() {
        String::new()
    } else {
        format!(", {args}")
    };

    let call_sql = if pkg.codegen.emit_query_constants {
        const_name.clone()
    } else {
        raw_string_literal(&q.sql)
    };

    let mut call = String::new();
    call.push_str(&format!("pgorm::query({call_sql})"));
    for (n, _t) in &param_decls {
        call.push_str(&format!(".bind({n})"));
    }

    let tag = &q.name;
    let (call, await_suffix) = match exec_method {
        ExecMethod::Execute => {
            if pkg.codegen.emit_tagged_exec {
                (
                    format!("{call}.execute_tagged(self.conn, \"{tag}\")"),
                    ".await",
                )
            } else {
                (format!("{call}.execute(self.conn)"), ".await")
            }
        }
        ExecMethod::FetchOne => {
            let row_name = row_struct.as_ref().unwrap().name.clone();
            if pkg.codegen.emit_tagged_exec {
                (
                    format!("{call}.fetch_one_tagged_as::<{row_name}>(self.conn, \"{tag}\")"),
                    ".await",
                )
            } else {
                (
                    format!("{call}.fetch_one_as::<{row_name}>(self.conn)"),
                    ".await",
                )
            }
        }
        ExecMethod::FetchOpt => {
            let row_name = row_struct.as_ref().unwrap().name.clone();
            if pkg.codegen.emit_tagged_exec {
                (
                    format!("{call}.fetch_opt_tagged_as::<{row_name}>(self.conn, \"{tag}\")"),
                    ".await",
                )
            } else {
                (
                    format!("{call}.fetch_opt_as::<{row_name}>(self.conn)"),
                    ".await",
                )
            }
        }
        ExecMethod::FetchAll => {
            let row_name = row_struct.as_ref().unwrap().name.clone();
            if pkg.codegen.emit_tagged_exec {
                (
                    format!("{call}.fetch_all_tagged_as::<{row_name}>(self.conn, \"{tag}\")"),
                    ".await",
                )
            } else {
                (
                    format!("{call}.fetch_all_as::<{row_name}>(self.conn)"),
                    ".await",
                )
            }
        }
    };

    if pkg.codegen.emit_queries_struct {
        out.push_str("impl<'a, C: pgorm::GenericClient> super::Queries<'a, C> {\n");
        out.push_str(&format!(
            "    pub async fn {fn_name}(&self{args_with_leading_comma}) -> {ret_ty} {{\n"
        ));
        out.push_str(&format!("        {call}{await_suffix}\n"));
        out.push_str("    }\n");
        out.push_str("}\n");
    } else {
        out.push_str(&format!(
            "pub async fn {fn_name}(conn: &impl GenericClient{args_with_leading_comma}) -> {ret_ty} {{\n"
        ));
        let call = call.replace("self.conn", "conn");
        out.push_str(&format!("    {call}{await_suffix}\n"));
        out.push_str("}\n");
    }

    Ok(())
}

#[derive(Debug, Clone, Copy)]
enum ExecMethod {
    FetchOne,
    FetchOpt,
    FetchAll,
    Execute,
}

#[derive(Debug, Clone)]
struct RowStruct {
    name: String,
    fields: Vec<RowField>,
}

#[derive(Debug, Clone)]
struct RowField {
    ident: String,
    column: String,
    ty: String,
}

impl RowStruct {
    fn render(&self, pkg: &PackageConfig) -> String {
        let mut out = String::new();

        if !pkg.codegen.row_derives.is_empty() {
            out.push_str("#[derive(");
            out.push_str(&pkg.codegen.row_derives.join(", "));
            out.push_str(")]\n");
        }
        out.push_str(&format!("pub struct {} {{\n", self.name));
        for f in &self.fields {
            if f.ident != f.column {
                out.push_str(&format!("    #[orm(column = \"{}\")]\n", f.column));
            }
            out.push_str(&format!("    pub {}: {},\n", f.ident, f.ty));
        }
        out.push_str("}\n");
        out
    }
}

fn build_row_struct(
    pkg: &PackageConfig,
    schema: &DbSchema,
    type_mapper: &TypeMapper,
    q: &QueryDef,
) -> anyhow::Result<RowStruct> {
    let analysis = pgorm_check::analyze_sql(&q.sql);
    if !analysis.parse_result.valid {
        anyhow::bail!("invalid SQL for {}", q.name);
    }

    let cols = extract_select_columns(&q.sql)?;
    let (visible_tables, qualifier_to_table) = build_table_resolution(schema, &analysis)?;

    let mut seen_columns: HashSet<String> = HashSet::new();
    let mut seen_idents: HashSet<String> = HashSet::new();
    let mut fields: Vec<RowField> = Vec::new();

    for SelectColumn { label, parts } in cols {
        if !seen_columns.insert(label.clone()) {
            anyhow::bail!("duplicate output column label in {}: {label}", q.name);
        }

        let (table_schema, table_name, col_name) =
            resolve_column_ref(schema, &visible_tables, &qualifier_to_table, &parts)?;

        let col = schema
            .find_table(&table_schema, &table_name)
            .and_then(|t| t.columns.iter().find(|c| c.name == col_name))
            .ok_or_else(|| {
                anyhow::anyhow!("column not found: {table_schema}.{table_name}.{col_name}")
            })?;

        let mut ty = if let Some(override_ty) = pkg.overrides.column_override(&q.name, &label) {
            override_ty.to_string()
        } else {
            type_mapper.map(&col.data_type)
        };

        if !col.not_null && !ty.starts_with("Option<") {
            ty = format!("Option<{ty}>");
        }

        let ident = sanitize_field_ident(&label);
        if !seen_idents.insert(ident.clone()) {
            anyhow::bail!(
                "duplicate field name in {} after sanitization: {ident}",
                q.name
            );
        }

        fields.push(RowField {
            ident,
            column: label,
            ty,
        });
    }

    Ok(RowStruct {
        name: sanitize_type_ident(&format!("{}Row", q.name)),
        fields,
    })
}

fn build_table_resolution(
    schema: &DbSchema,
    analysis: &pgorm_check::SqlAnalysis,
) -> anyhow::Result<TableResolution> {
    let mut visible_tables: Vec<(String, String)> = Vec::new();
    let mut qualifier_to_table: HashMap<String, (String, String)> = HashMap::new();

    for rv in &analysis.range_vars {
        if analysis.cte_names.contains(&rv.table) {
            continue;
        }

        let rel_schema = rv.schema.as_deref();
        let rel_name = rv.table.as_str();
        let qualifier = rv.alias.as_deref().unwrap_or(rel_name).to_string();

        let Some((resolved_schema, resolved_table)) = resolve_table(schema, rel_schema, rel_name)?
        else {
            anyhow::bail!(
                "table not found: {}",
                match rel_schema {
                    Some(s) => format!("{s}.{rel_name}"),
                    None => rel_name.to_string(),
                }
            );
        };

        // If an alias exists, the base name is not visible (matches pgorm-check behavior).
        if qualifier_to_table
            .insert(qualifier, (resolved_schema.clone(), resolved_table.clone()))
            .is_none()
        {
            visible_tables.push((resolved_schema, resolved_table));
        }
    }

    Ok((visible_tables, qualifier_to_table))
}

fn resolve_table(
    schema: &DbSchema,
    explicit_schema: Option<&str>,
    table: &str,
) -> anyhow::Result<Option<(String, String)>> {
    if let Some(s) = explicit_schema {
        return Ok(schema
            .find_table(s, table)
            .map(|_| (s.to_string(), table.to_string())));
    }

    let mut found: Option<(String, String)> = None;
    for s in &schema.schemas {
        if schema.find_table(s, table).is_some() {
            if found.is_some() {
                anyhow::bail!("table name is ambiguous in configured schemas: {table}");
            }
            found = Some((s.to_string(), table.to_string()));
        }
    }

    Ok(found)
}

fn resolve_column_ref(
    schema: &DbSchema,
    visible_tables: &[(String, String)],
    qualifier_to_table: &HashMap<String, (String, String)>,
    parts: &[String],
) -> anyhow::Result<(String, String, String)> {
    if parts.is_empty() {
        anyhow::bail!("invalid column reference");
    }

    // Unqualified: col
    if parts.len() == 1 {
        let col = parts[0].as_str();

        let mut found: Option<(String, String)> = None;
        for (s, t) in visible_tables {
            if schema
                .find_table(s, t)
                .is_some_and(|table| table.columns.iter().any(|c| c.name == col))
            {
                if found.is_some() {
                    anyhow::bail!("ambiguous column reference: {col}");
                }
                found = Some((s.clone(), t.clone()));
            }
        }

        let Some((s, t)) = found else {
            anyhow::bail!("column not found: {col}");
        };

        return Ok((s, t, col.to_string()));
    }

    // Qualified: qualifier.col
    if parts.len() == 2 {
        let qualifier = parts[0].as_str();
        let col = parts[1].clone();
        let Some((s, t)) = qualifier_to_table.get(qualifier).cloned() else {
            anyhow::bail!("unknown table/alias qualifier: {qualifier}");
        };
        return Ok((s, t, col));
    }

    // schema.table.col OR catalog.schema.table.col
    if parts.len() == 3 || parts.len() == 4 {
        let (schema_part, table_part, col_part) = if parts.len() == 3 {
            (&parts[0], &parts[1], &parts[2])
        } else {
            (&parts[1], &parts[2], &parts[3])
        };

        if schema.find_table(schema_part, table_part).is_none() {
            anyhow::bail!("table not found: {schema_part}.{table_part}");
        }

        return Ok((schema_part.clone(), table_part.clone(), col_part.clone()));
    }

    anyhow::bail!("unsupported column reference shape (MVP): {parts:?}");
}

fn to_snake(s: &str) -> String {
    heck::ToSnakeCase::to_snake_case(s)
}

fn to_shouty_snake(s: &str) -> String {
    heck::ToShoutySnakeCase::to_shouty_snake_case(s)
}

fn sanitize_type_ident(name: &str) -> String {
    let mut s = name
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect::<String>();

    if s.is_empty() {
        s.push('_');
    }

    if s.chars().next().unwrap().is_ascii_digit() {
        s.insert(0, '_');
    }

    s
}

fn sanitize_field_ident(column: &str) -> String {
    let mut s = column
        .chars()
        .map(|c| if c.is_ascii_alphanumeric() { c } else { '_' })
        .collect::<String>();
    s = heck::ToSnakeCase::to_snake_case(s.as_str());
    if s.is_empty() {
        s.push('_');
    }
    if s.chars().next().unwrap().is_ascii_digit() {
        s.insert(0, '_');
    }
    if is_rust_keyword(&s) {
        format!("r#{s}")
    } else {
        s
    }
}

fn is_rust_keyword(s: &str) -> bool {
    matches!(
        s,
        "as" | "break"
            | "const"
            | "continue"
            | "crate"
            | "else"
            | "enum"
            | "extern"
            | "false"
            | "fn"
            | "for"
            | "if"
            | "impl"
            | "in"
            | "let"
            | "loop"
            | "match"
            | "mod"
            | "move"
            | "mut"
            | "pub"
            | "ref"
            | "return"
            | "self"
            | "Self"
            | "static"
            | "struct"
            | "super"
            | "trait"
            | "true"
            | "type"
            | "unsafe"
            | "use"
            | "where"
            | "while"
            | "async"
            | "await"
            | "dyn"
    )
}

fn raw_string_literal(s: &str) -> String {
    let mut hashes = 1usize;
    loop {
        let end = format!("\"{}", "#".repeat(hashes));
        if !s.contains(&end) {
            break;
        }
        hashes += 1;
    }
    let hashes_str = "#".repeat(hashes);
    format!("r{hashes_str}\"{s}\"{hashes_str}")
}
