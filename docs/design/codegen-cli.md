# 代码生成 CLI (Schema-to-Code Generator)

> 参考来源：jOOQ (Java)、Prisma (TypeScript)、SQLAlchemy Automap

## 概述

代码生成 CLI 工具从现有数据库 schema 自动生成 Rust 模型代码，实现 Database-First 的开发工作流。这大大降低了将现有项目迁移到 pgorm 的门槛。

## 设计原则

- **准确映射**：精确反映数据库 schema，包括类型、约束、索引
- **可定制**：支持配置文件自定义生成规则
- **增量更新**：支持在不覆盖手动修改的情况下更新
- **类型安全**：生成的代码通过编译即可保证与数据库一致

## 使用方式

### 基本命令

```bash
# 从数据库生成模型
pgorm generate \
    --database "postgres://user:pass@localhost/mydb" \
    --output src/models/

# 使用配置文件
pgorm generate --config pgorm.toml

# 只生成特定表
pgorm generate \
    --database "postgres://..." \
    --tables users,posts,comments \
    --output src/models/

# 排除特定表
pgorm generate \
    --database "postgres://..." \
    --exclude "_migrations,_schema_history" \
    --output src/models/

# 预览生成内容（不写入文件）
pgorm generate --database "postgres://..." --dry-run
```

### 配置文件

```toml
# pgorm.toml

[database]
url = "postgres://user:pass@localhost/mydb"
# 或使用环境变量
# url = "${DATABASE_URL}"

[output]
path = "src/models"
# 生成单个文件还是多个文件
mode = "multiple"  # "single" | "multiple"

[generation]
# 生成哪些 derive
derives = ["Model", "FromRow", "InsertModel", "UpdateModel", "Debug", "Clone"]

# 是否生成关系
generate_relations = true

# 是否生成索引信息
generate_indexes = true

# 命名风格
table_naming = "snake_case"   # 表名保持不变
struct_naming = "PascalCase"  # 结构体名
field_naming = "snake_case"   # 字段名

[tables]
# 包含/排除表
include = ["*"]
exclude = ["_migrations", "_schema_history", "pg_*"]

# 特定表的配置
[tables.users]
struct_name = "User"  # 自定义结构体名
# 字段覆盖
[tables.users.columns.password_hash]
skip = true  # 不生成此字段
[tables.users.columns.created_at]
rust_type = "DateTime<Utc>"  # 自定义类型

[tables.user_profiles]
struct_name = "Profile"

[types]
# 自定义类型映射
"uuid" = "uuid::Uuid"
"jsonb" = "serde_json::Value"
"timestamptz" = "chrono::DateTime<chrono::Utc>"
"timestamp" = "chrono::NaiveDateTime"
"numeric" = "rust_decimal::Decimal"
"inet" = "std::net::IpAddr"

[imports]
# 额外的 use 语句
extra = [
    "chrono::{DateTime, Utc, NaiveDateTime}",
    "uuid::Uuid",
    "serde_json::Value as JsonValue",
    "rust_decimal::Decimal",
]
```

## 生成的代码示例

### 输入：数据库 Schema

```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    uuid UUID NOT NULL DEFAULT gen_random_uuid() UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    age INTEGER,
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    metadata JSONB,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);

CREATE TABLE posts (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    status VARCHAR(20) NOT NULL DEFAULT 'draft',
    published_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_status ON posts(status);

CREATE TABLE comments (
    id BIGSERIAL PRIMARY KEY,
    post_id BIGINT NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

### 输出：生成的 Rust 代码

```rust
// src/models/mod.rs (自动生成)
//! Database models generated by pgorm-cli
//!
//! Generated at: 2024-12-20T10:30:00Z
//! Database: postgres://localhost/mydb
//!
//! DO NOT EDIT - This file is auto-generated.
//! To customize, use pgorm.toml configuration.

mod user;
mod post;
mod comment;

pub use user::*;
pub use post::*;
pub use comment::*;
```

```rust
// src/models/user.rs (自动生成)
//! Model for table `users`

use chrono::{DateTime, Utc};
use pgorm::{FromRow, Model, InsertModel, UpdateModel};
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;
use uuid::Uuid;

/// User model
///
/// Table: `users`
/// Primary key: `id`
/// Indexes:
///   - `idx_users_email` (email)
///   - `idx_users_status` (status)
#[derive(Debug, Clone, Model, FromRow, Serialize, Deserialize)]
#[orm(table = "users")]
#[orm(has_many(Post, foreign_key = "user_id", as = "posts"))]
#[orm(has_many(Comment, foreign_key = "user_id", as = "comments"))]
pub struct User {
    /// Primary key
    #[orm(id)]
    pub id: i64,

    /// Unique identifier
    #[orm(column = "uuid")]
    pub uuid: Uuid,

    /// User email address
    /// Unique constraint: `users_email_key`
    pub email: String,

    /// User display name
    pub name: String,

    /// User age (optional)
    pub age: Option<i32>,

    /// Account status
    /// Default: 'active'
    pub status: String,

    /// Additional metadata
    pub metadata: Option<JsonValue>,

    /// Creation timestamp
    pub created_at: DateTime<Utc>,

    /// Last update timestamp
    pub updated_at: DateTime<Utc>,
}

/// Insert model for `users`
#[derive(Debug, Clone, InsertModel, Serialize, Deserialize)]
#[orm(table = "users")]
#[orm(returning = "User")]
pub struct NewUser {
    /// Unique identifier (auto-generated if not provided)
    #[orm(default)]
    pub uuid: Option<Uuid>,

    /// User email address
    pub email: String,

    /// User display name
    pub name: String,

    /// Password hash (write-only)
    pub password_hash: String,

    /// User age (optional)
    pub age: Option<i32>,

    /// Account status
    #[orm(default)]
    pub status: Option<String>,

    /// Additional metadata
    pub metadata: Option<JsonValue>,

    /// Creation timestamp (auto-generated)
    #[orm(auto_now_add)]
    pub created_at: Option<DateTime<Utc>>,

    /// Last update timestamp (auto-generated)
    #[orm(auto_now_add)]
    pub updated_at: Option<DateTime<Utc>>,
}

/// Update model for `users`
#[derive(Debug, Clone, Default, UpdateModel, Serialize, Deserialize)]
#[orm(table = "users")]
pub struct UpdateUser {
    /// User email address
    pub email: Option<String>,

    /// User display name
    pub name: Option<String>,

    /// Password hash
    pub password_hash: Option<String>,

    /// User age
    /// Use `Some(None)` to set to NULL
    pub age: Option<Option<i32>>,

    /// Account status
    pub status: Option<String>,

    /// Additional metadata
    /// Use `Some(None)` to set to NULL
    pub metadata: Option<Option<JsonValue>>,

    /// Last update timestamp (auto-updated)
    #[orm(auto_now)]
    pub updated_at: Option<DateTime<Utc>>,
}
```

```rust
// src/models/post.rs (自动生成)
//! Model for table `posts`

use chrono::{DateTime, Utc};
use pgorm::{FromRow, Model, InsertModel, UpdateModel};
use serde::{Deserialize, Serialize};

/// Post model
///
/// Table: `posts`
/// Primary key: `id`
/// Foreign keys:
///   - `user_id` -> `users(id)` ON DELETE CASCADE
#[derive(Debug, Clone, Model, FromRow, Serialize, Deserialize)]
#[orm(table = "posts")]
#[orm(belongs_to(User, foreign_key = "user_id", as = "author"))]
#[orm(has_many(Comment, foreign_key = "post_id", as = "comments"))]
pub struct Post {
    #[orm(id)]
    pub id: i64,

    /// Author reference
    pub user_id: i64,

    pub title: String,

    pub content: Option<String>,

    /// Post status: draft, published, archived
    pub status: String,

    pub published_at: Option<DateTime<Utc>>,

    pub created_at: DateTime<Utc>,

    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, InsertModel, Serialize, Deserialize)]
#[orm(table = "posts")]
#[orm(returning = "Post")]
pub struct NewPost {
    pub user_id: i64,

    pub title: String,

    pub content: Option<String>,

    #[orm(default)]
    pub status: Option<String>,

    pub published_at: Option<DateTime<Utc>>,

    #[orm(auto_now_add)]
    pub created_at: Option<DateTime<Utc>>,

    #[orm(auto_now_add)]
    pub updated_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Default, UpdateModel, Serialize, Deserialize)]
#[orm(table = "posts")]
pub struct UpdatePost {
    pub title: Option<String>,

    pub content: Option<Option<String>>,

    pub status: Option<String>,

    pub published_at: Option<Option<DateTime<Utc>>>,

    #[orm(auto_now)]
    pub updated_at: Option<DateTime<Utc>>,
}
```

## CLI 架构

### 命令结构

```
pgorm
├── generate          # 生成模型代码
│   ├── --database    # 数据库连接字符串
│   ├── --config      # 配置文件路径
│   ├── --output      # 输出目录
│   ├── --tables      # 指定表
│   ├── --exclude     # 排除表
│   ├── --dry-run     # 预览模式
│   └── --force       # 覆盖现有文件
│
├── diff              # 比较数据库与现有代码的差异
│   ├── --database    # 数据库连接字符串
│   └── --models      # 模型文件路径
│
├── check             # 验证模型与数据库一致性
│   ├── --database    # 数据库连接字符串
│   └── --models      # 模型文件路径
│
└── init              # 初始化配置文件
    └── --database    # 数据库连接字符串（可选）
```

### 核心模块

```rust
// pgorm-cli/src/main.rs

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "pgorm")]
#[command(about = "pgorm CLI - Database-first code generation")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate Rust models from database schema
    Generate(GenerateArgs),
    /// Compare database schema with existing models
    Diff(DiffArgs),
    /// Validate models against database schema
    Check(CheckArgs),
    /// Initialize pgorm.toml configuration
    Init(InitArgs),
}

#[derive(Args)]
struct GenerateArgs {
    /// Database connection URL
    #[arg(short, long, env = "DATABASE_URL")]
    database: Option<String>,

    /// Configuration file path
    #[arg(short, long, default_value = "pgorm.toml")]
    config: PathBuf,

    /// Output directory
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Tables to include (comma-separated)
    #[arg(long)]
    tables: Option<String>,

    /// Tables to exclude (comma-separated)
    #[arg(long)]
    exclude: Option<String>,

    /// Preview without writing files
    #[arg(long)]
    dry_run: bool,

    /// Overwrite existing files
    #[arg(long)]
    force: bool,
}
```

## Schema 解析

### 数据库内省

```rust
// pgorm-cli/src/introspect.rs

use tokio_postgres::Client;

/// 表信息
pub struct TableInfo {
    pub name: String,
    pub schema: String,
    pub columns: Vec<ColumnInfo>,
    pub primary_key: Option<Vec<String>>,
    pub indexes: Vec<IndexInfo>,
    pub foreign_keys: Vec<ForeignKeyInfo>,
    pub unique_constraints: Vec<UniqueConstraintInfo>,
    pub check_constraints: Vec<CheckConstraintInfo>,
    pub comment: Option<String>,
}

/// 列信息
pub struct ColumnInfo {
    pub name: String,
    pub data_type: String,
    pub udt_name: String,
    pub is_nullable: bool,
    pub default_value: Option<String>,
    pub is_identity: bool,
    pub is_generated: bool,
    pub comment: Option<String>,
}

/// 索引信息
pub struct IndexInfo {
    pub name: String,
    pub columns: Vec<String>,
    pub is_unique: bool,
    pub is_primary: bool,
}

/// 外键信息
pub struct ForeignKeyInfo {
    pub name: String,
    pub columns: Vec<String>,
    pub referenced_table: String,
    pub referenced_columns: Vec<String>,
    pub on_delete: String,
    pub on_update: String,
}

/// 从数据库读取 schema
pub async fn introspect_database(client: &Client) -> Result<Vec<TableInfo>, Error> {
    // 查询 information_schema
    let tables = query_tables(client).await?;
    let mut result = Vec::new();

    for table in tables {
        let columns = query_columns(client, &table.name).await?;
        let primary_key = query_primary_key(client, &table.name).await?;
        let indexes = query_indexes(client, &table.name).await?;
        let foreign_keys = query_foreign_keys(client, &table.name).await?;
        let unique_constraints = query_unique_constraints(client, &table.name).await?;

        result.push(TableInfo {
            name: table.name,
            schema: table.schema,
            columns,
            primary_key,
            indexes,
            foreign_keys,
            unique_constraints,
            check_constraints: vec![],
            comment: table.comment,
        });
    }

    Ok(result)
}

/// 查询列信息的 SQL
async fn query_columns(client: &Client, table_name: &str) -> Result<Vec<ColumnInfo>, Error> {
    let sql = r#"
        SELECT
            c.column_name,
            c.data_type,
            c.udt_name,
            c.is_nullable = 'YES' as is_nullable,
            c.column_default,
            c.is_identity = 'YES' as is_identity,
            c.is_generated != 'NEVER' as is_generated,
            pgd.description as comment
        FROM information_schema.columns c
        LEFT JOIN pg_catalog.pg_statio_all_tables st
            ON c.table_schema = st.schemaname AND c.table_name = st.relname
        LEFT JOIN pg_catalog.pg_description pgd
            ON pgd.objoid = st.relid AND pgd.objsubid = c.ordinal_position
        WHERE c.table_name = $1
        ORDER BY c.ordinal_position
    "#;

    let rows = client.query(sql, &[&table_name]).await?;
    // ... 解析结果
}
```

## 类型映射

### PostgreSQL 到 Rust 类型映射

```rust
// pgorm-cli/src/type_mapping.rs

use std::collections::HashMap;

pub struct TypeMapper {
    mappings: HashMap<String, String>,
}

impl TypeMapper {
    pub fn new() -> Self {
        let mut mappings = HashMap::new();

        // 数值类型
        mappings.insert("smallint".into(), "i16".into());
        mappings.insert("int2".into(), "i16".into());
        mappings.insert("integer".into(), "i32".into());
        mappings.insert("int4".into(), "i32".into());
        mappings.insert("bigint".into(), "i64".into());
        mappings.insert("int8".into(), "i64".into());
        mappings.insert("smallserial".into(), "i16".into());
        mappings.insert("serial".into(), "i32".into());
        mappings.insert("bigserial".into(), "i64".into());
        mappings.insert("real".into(), "f32".into());
        mappings.insert("float4".into(), "f32".into());
        mappings.insert("double precision".into(), "f64".into());
        mappings.insert("float8".into(), "f64".into());
        mappings.insert("numeric".into(), "rust_decimal::Decimal".into());
        mappings.insert("decimal".into(), "rust_decimal::Decimal".into());

        // 字符串类型
        mappings.insert("character varying".into(), "String".into());
        mappings.insert("varchar".into(), "String".into());
        mappings.insert("character".into(), "String".into());
        mappings.insert("char".into(), "String".into());
        mappings.insert("text".into(), "String".into());
        mappings.insert("name".into(), "String".into());

        // 布尔类型
        mappings.insert("boolean".into(), "bool".into());
        mappings.insert("bool".into(), "bool".into());

        // 时间类型
        mappings.insert("timestamp without time zone".into(), "chrono::NaiveDateTime".into());
        mappings.insert("timestamp".into(), "chrono::NaiveDateTime".into());
        mappings.insert("timestamp with time zone".into(), "chrono::DateTime<chrono::Utc>".into());
        mappings.insert("timestamptz".into(), "chrono::DateTime<chrono::Utc>".into());
        mappings.insert("date".into(), "chrono::NaiveDate".into());
        mappings.insert("time without time zone".into(), "chrono::NaiveTime".into());
        mappings.insert("time".into(), "chrono::NaiveTime".into());
        mappings.insert("time with time zone".into(), "chrono::NaiveTime".into());
        mappings.insert("interval".into(), "chrono::Duration".into());

        // UUID
        mappings.insert("uuid".into(), "uuid::Uuid".into());

        // JSON
        mappings.insert("json".into(), "serde_json::Value".into());
        mappings.insert("jsonb".into(), "serde_json::Value".into());

        // 二进制
        mappings.insert("bytea".into(), "Vec<u8>".into());

        // 网络类型
        mappings.insert("inet".into(), "std::net::IpAddr".into());
        mappings.insert("cidr".into(), "ipnetwork::IpNetwork".into());
        mappings.insert("macaddr".into(), "macaddr::MacAddr6".into());

        // 数组类型会在运行时处理

        Self { mappings }
    }

    pub fn map_type(&self, pg_type: &str, is_nullable: bool, is_array: bool) -> String {
        let base_type = self.mappings
            .get(pg_type)
            .cloned()
            .unwrap_or_else(|| {
                // 未知类型，使用 String
                eprintln!("Warning: Unknown PostgreSQL type '{}', using String", pg_type);
                "String".into()
            });

        let typed = if is_array {
            format!("Vec<{}>", base_type)
        } else {
            base_type
        };

        if is_nullable {
            format!("Option<{}>", typed)
        } else {
            typed
        }
    }

    /// 添加自定义映射
    pub fn add_mapping(&mut self, pg_type: &str, rust_type: &str) {
        self.mappings.insert(pg_type.to_string(), rust_type.to_string());
    }
}
```

## 代码生成

### 代码生成器

```rust
// pgorm-cli/src/codegen.rs

use quote::quote;
use proc_macro2::TokenStream;

pub struct CodeGenerator {
    config: Config,
    type_mapper: TypeMapper,
}

impl CodeGenerator {
    pub fn generate_model(&self, table: &TableInfo) -> String {
        let struct_name = self.to_struct_name(&table.name);
        let table_name = &table.name;

        // 生成字段
        let fields = self.generate_fields(&table.columns);

        // 生成关系
        let relations = self.generate_relations(table);

        // 生成文档注释
        let doc = self.generate_doc(table);

        let code = quote! {
            #doc
            #[derive(Debug, Clone, Model, FromRow, Serialize, Deserialize)]
            #[orm(table = #table_name)]
            #relations
            pub struct #struct_name {
                #fields
            }
        };

        code.to_string()
    }

    pub fn generate_insert_model(&self, table: &TableInfo) -> String {
        // ... 生成 InsertModel
    }

    pub fn generate_update_model(&self, table: &TableInfo) -> String {
        // ... 生成 UpdateModel
    }

    fn generate_fields(&self, columns: &[ColumnInfo]) -> TokenStream {
        let fields: Vec<_> = columns.iter().map(|col| {
            let name = format_ident!("{}", col.name);
            let ty: TokenStream = self.type_mapper
                .map_type(&col.udt_name, col.is_nullable, false)
                .parse()
                .unwrap();

            let attrs = self.generate_field_attrs(col);

            quote! {
                #attrs
                pub #name: #ty,
            }
        }).collect();

        quote! { #(#fields)* }
    }

    fn generate_field_attrs(&self, col: &ColumnInfo) -> TokenStream {
        let mut attrs = vec![];

        // 主键
        if col.is_identity {
            attrs.push(quote! { #[orm(id)] });
        }

        // 默认值
        if col.default_value.is_some() && !col.is_identity {
            attrs.push(quote! { #[orm(default)] });
        }

        // 列名映射（如果不同）
        let field_name = self.to_field_name(&col.name);
        if field_name != col.name {
            let col_name = &col.name;
            attrs.push(quote! { #[orm(column = #col_name)] });
        }

        quote! { #(#attrs)* }
    }
}
```

## Diff 和 Check 命令

### Schema 差异检测

```rust
// pgorm-cli/src/diff.rs

pub struct SchemaDiff {
    pub added_tables: Vec<TableInfo>,
    pub removed_tables: Vec<String>,
    pub modified_tables: Vec<TableDiff>,
}

pub struct TableDiff {
    pub table_name: String,
    pub added_columns: Vec<ColumnInfo>,
    pub removed_columns: Vec<String>,
    pub modified_columns: Vec<ColumnDiff>,
    pub added_indexes: Vec<IndexInfo>,
    pub removed_indexes: Vec<String>,
}

pub struct ColumnDiff {
    pub column_name: String,
    pub old_type: String,
    pub new_type: String,
    pub nullable_changed: Option<bool>,
    pub default_changed: bool,
}

/// 比较数据库和模型
pub fn diff_schema(
    db_schema: &[TableInfo],
    model_schema: &[TableInfo],
) -> SchemaDiff {
    // 实现差异计算
}

/// 输出差异报告
pub fn print_diff(diff: &SchemaDiff) {
    if diff.added_tables.is_empty()
        && diff.removed_tables.is_empty()
        && diff.modified_tables.is_empty()
    {
        println!("✓ Schema is up to date");
        return;
    }

    for table in &diff.added_tables {
        println!("+ Table: {}", table.name);
    }

    for table in &diff.removed_tables {
        println!("- Table: {}", table);
    }

    for table_diff in &diff.modified_tables {
        println!("~ Table: {}", table_diff.table_name);
        for col in &table_diff.added_columns {
            println!("  + Column: {}", col.name);
        }
        for col in &table_diff.removed_columns {
            println!("  - Column: {}", col);
        }
        for col in &table_diff.modified_columns {
            println!("  ~ Column: {} ({} -> {})", col.column_name, col.old_type, col.new_type);
        }
    }
}
```

## 实现检查清单

### CLI 框架
- [ ] 设置 clap CLI 结构
- [ ] 实现 `generate` 命令
- [ ] 实现 `diff` 命令
- [ ] 实现 `check` 命令
- [ ] 实现 `init` 命令

### 数据库内省
- [ ] 查询表信息
- [ ] 查询列信息
- [ ] 查询主键信息
- [ ] 查询索引信息
- [ ] 查询外键信息
- [ ] 查询唯一约束
- [ ] 查询检查约束
- [ ] 查询表/列注释

### 类型映射
- [ ] 基础类型映射
- [ ] 数组类型处理
- [ ] 自定义类型支持
- [ ] 枚举类型处理

### 代码生成
- [ ] Model 结构体生成
- [ ] InsertModel 生成
- [ ] UpdateModel 生成
- [ ] 关系生成
- [ ] 文档注释生成
- [ ] mod.rs 生成

### 配置
- [ ] TOML 配置解析
- [ ] 环境变量支持
- [ ] 表级配置
- [ ] 列级配置
- [ ] 自定义类型映射

### 其他
- [ ] 增量更新支持
- [ ] Dry-run 模式
- [ ] 差异检测
- [ ] Schema 验证
- [ ] 单元测试
- [ ] 集成测试
- [ ] 文档
