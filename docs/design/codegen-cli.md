# 代码生成 CLI（SQL-to-Code Generator，sqlc-like）

> 参考来源：sqlc（Go）、sqlx（Rust）、libpg_query / pg_query（Postgres SQL Parser）

## 背景

pgorm 的定位是 **SQL-first**：开发者写清晰、可 review 的 SQL，并用 `pgorm::query()`/`pgorm::sql()` 执行、绑定参数、映射结果。

现阶段的痛点是：

- 手写 SQL → 手写绑定顺序 / 结构体字段 → 容易出错、重复劳动
- 需要“像 sqlc 一样”：**给定 schema + queries.sql，生成类型安全的调用代码**
- 希望尽量“离线”：不依赖运行时连数据库也能生成（CI 也能跑）

因此，这里的 codegen CLI 目标从「Schema-to-Code（内省生成模型）」**完全切换**为「SQL-to-Code（基于 SQL 文件生成调用层）」。

## 核心目标 / 非目标

### 目标（MVP）

- **Query-first**：以 `queries/**/*.sql` 为输入，生成 Rust 调用代码
- **类型安全**：参数类型、返回行类型尽可能从 schema 推导（推导失败可显式标注）
- **和 pgorm API 对齐**：生成代码使用 `pgorm::query()` + `bind()` + `fetch_*_as()`/`execute()`
- **可组合、可维护**：生成代码稳定（命名稳定、文件布局稳定），方便 diff/review

### 非目标（先不做）

- 自动生成 migrations / DDL（属于迁移工具范畴）
- 解析支持所有 PostgreSQL 语法角落（先覆盖常见 DML：SELECT/INSERT/UPDATE/DELETE/CTE）
- 运行期“反射”数据库推导类型（可作为可选校验，但不作为唯一信息源）

## 使用方式（面向开发者）

### 目录约定（建议）

```
.
├── migrations/              # refinery 迁移（可选，作为 schema 源）
│   ├── V001__init.sql
│   └── ...
├── queries/                 # 手写 SQL（核心输入）
│   ├── users.sql
│   └── posts.sql
├── pgorm.toml               # codegen 配置（本设计）
└── src/db/                  # 生成输出目录（示例）
```

### 基本命令

```bash
# 生成（类似：sqlc generate）
pgorm gen --config pgorm.toml

# 只检查（解析/类型推导/SQL lint），不写文件（适合 CI）
pgorm gen check --config pgorm.toml

# 初始化配置模板
pgorm gen init

# （可选）从数据库刷新本地 schema cache（如果你不想/不能解析 migrations）
pgorm gen schema --database "$DATABASE_URL"
```

## 配置文件（pgorm.toml）

设计上尽量贴近 sqlc 的“多 package”概念：一个项目可能有多套 schema/queries 输出到不同 module。

```toml
# pgorm.toml

version = "1"
engine = "postgres"

[[packages]]
name = "db"
schema = ["migrations/**/*.sql"]   # 或者 ["schema.sql"]，也可以走 schema_cache
queries = ["queries/**/*.sql"]
out = "src/db"

[packages.codegen]
# 生成风格
emit_queries_struct = true      # 生成 Queries<C> 结构体（sqlc 风格）
emit_query_constants = true     # 为每个 query 生成 const SQL: &str
emit_tagged_exec = true         # 使用 fetch_*_tagged*/execute_tagged（便于监控）

# 派生与常用导入
derives = ["Debug", "Clone"]    # 默认给参数/返回 struct
row_derives = ["FromRow"]       # 返回行结构体 derive
extra_uses = [
  "pgorm::FromRow",
  "serde::{Serialize, Deserialize}",
]

# 命名
module_naming = "snake_case"    # 生成模块名
type_naming = "PascalCase"      # 生成 struct/enum 名
field_naming = "snake_case"     # 生成字段名

[packages.types]
# PG 类型到 Rust 类型映射（可覆盖默认）
"uuid" = "uuid::Uuid"
"timestamptz" = "chrono::DateTime<chrono::Utc>"
"jsonb" = "serde_json::Value"
"numeric" = "rust_decimal::Decimal"

[packages.overrides]
# 当推导失败/需要显式指定时使用（按需扩展）
# 参数类型覆盖（query_name + 位置）
# param."GetUser".1 = "i64"
#
# 返回字段类型覆盖（query_name + 字段名）
# column."SearchUsers".created_at = "chrono::DateTime<chrono::Utc>"
```

说明：

- `schema`：优先推荐从 migrations/schema.sql 解析获得 schema 信息；如果做不到，可通过 `schema` 子命令生成 `.pgorm/schema.json` 作为输入（见下文）。
- `overrides`：用于处理“SQL 推导困难”的场景（表达式、函数、动态列等）。

## Query 文件格式（sqlc 风格注解）

每个 query 用一段注释声明元信息：

```sql
-- name: GetUser :one
SELECT id, email, name, created_at
FROM users
WHERE id = $1;

-- name: ListUsersByStatus :many
SELECT id, email, name
FROM users
WHERE status = $1
ORDER BY id DESC
LIMIT $2 OFFSET $3;

-- name: UpdateUserName :execrows
UPDATE users
SET name = $2
WHERE id = $1;

-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1;
```

返回类型标记（与 sqlc 类似，按 pgorm 能力收敛）：

- `:one`：返回 1 行（无行视为错误） → `fetch_one_as()`
- `:opt`：返回 0/1 行 → `fetch_opt_as()`
- `:many`：返回多行 → `fetch_all_as()`
- `:exec`：无返回行 → `execute()`（返回 `u64` affected rows 或丢弃）
- `:execrows`：同 `:exec`，但语义上鼓励使用返回值（`u64`）

额外注解（可选，逐步加入）：

- `-- @param <pos> <name> <rust_type>`：显式命名/指定参数
- `-- @result <rust_type>`：强制使用现有类型作为返回行（例如自写 Model/DTO）
- `-- @tag <string>`：覆盖监控 tag（默认用 query name）

## 生成输出（Rust）

### 生成文件布局（建议）

以 `packages.name = "db"`, `out = "src/db"` 为例：

```
src/db/
├── mod.rs               # 自动生成：pub mod users; pub mod posts; ...
├── users.rs             # 来自 queries/users.sql
└── posts.rs             # 来自 queries/posts.sql
```

每个模块包含（按配置开关）：

- `const SQL_*: &str`：原始 SQL（便于排查/日志对齐）
- `struct <QueryName>Params`（可选）：当参数多/需要命名时生成
- `struct <QueryName>Row`：`SELECT` 返回行结构体（`#[derive(FromRow, ...)]`）
- `impl Queries<C>` 方法：每个 query 一个 `async fn`

### 生成代码示例

输入（`queries/users.sql`）：

```sql
-- name: GetUser :opt
SELECT id, email, name
FROM users
WHERE id = $1;
```

输出（`src/db/users.rs`，示意）：

```rust
// Code generated by pgorm. DO NOT EDIT.

use pgorm::{query, GenericClient, OrmResult, FromRow};

pub struct Queries<'a, C: GenericClient> {
    conn: &'a C,
}

impl<'a, C: GenericClient> Queries<'a, C> {
    pub fn new(conn: &'a C) -> Self {
        Self { conn }
    }

    pub async fn get_user(&self, id: i64) -> OrmResult<Option<GetUserRow>> {
        const SQL: &str = r#"
            SELECT id, email, name
            FROM users
            WHERE id = $1
        "#;

        query(SQL)
            .bind(id)
            .fetch_opt_tagged_as(self.conn, "GetUser")
            .await
    }
}

#[derive(Debug, Clone, FromRow)]
pub struct GetUserRow {
    pub id: i64,
    pub email: String,
    pub name: String,
}
```

## Schema 来源与类型推导

sqlc 的关键点是：**不连数据库**也能推导类型。这里也采用同样的思路，但保留可选的 DB 校验通道。

### Schema 输入优先级（建议）

1. `schema = ["migrations/**/*.sql"]` 或 `schema = ["schema.sql"]`：从 DDL 解析出表/列/类型/可空信息（推荐）
2. `.pgorm/schema.json`：本地 schema cache（可由 `pgorm gen schema --database ...` 生成）
3. `--database`（可选）：仅用于校验/刷新 cache，不作为唯一信息源（避免 CI 依赖 DB）

### 推导规则（MVP 版）

参数：

- `$n` 参数按出现顺序生成函数参数
- 若 `$n` 出现在 `col = $n / $n = col / col IN (...)`，优先使用 `col` 的类型
- 若 `$n` 出现在 `INSERT/UPDATE` 的列赋值位置，使用对应列类型
- 推导失败时：
  - 要求 SQL 中显式 cast：`$1::uuid`
  - 或使用 `-- @param` / `packages.overrides` 指定

返回行：

- `SELECT col1, col2 ...`：从列引用解析类型与可空
- `SELECT *`：默认报错（避免生成不稳定类型）；后续可提供 `-- @result User` 或 `sqlc.embed` 类能力
- `LEFT JOIN`：来自被左连接表的列默认为可空（`Option<T>`）
- 表达式（`COUNT(*)`, `COALESCE`, `NOW()` 等）：MVP 先要求显式 cast 或 override

类型映射：

- 内置一套 PG → Rust 映射（与 pgorm 已用依赖对齐：chrono/uuid/serde_json 等）
- `packages.types` 允许覆盖/扩展

## CLI 内部架构（实现视角）

### Pipeline

1. 读取配置（多 package）
2. 对每个 package：
   1) 加载 schema（migrations/schema.sql/schema cache）
   2) 扫描 queries 文件，按 `-- name:` 分段
   3) 用 `pg_query` 解析 DDL/DML AST
   4) 基于 schema 做参数/返回类型推导，必要时应用 overrides
   5) 生成 Rust 源码（模块/struct/方法），写入 `out`
   6) 可选：rustfmt（由 CLI flag 控制，默认不强依赖）

### 与 pgorm-check 的关系

- 复用 `pgorm-check` 的 SQL 解析/引用提取能力（已有 `pg_query` feature）
- codegen 的 `check` 子命令可以顺便跑 lint（如：UPDATE/DELETE 必须有 WHERE、SELECT MANY 建议 LIMIT 等）

## 实现检查清单（迭代）

### CLI 框架

- [ ] `pgorm gen`/`pgorm gen check`/`pgorm gen init` 命令骨架（clap）
- [ ] 配置解析（支持 multi-package）
- [ ] 文件扫描与 query 分段（按 `-- name:`）

### Schema 输入

- [ ] DDL 解析（CREATE TABLE / ALTER TABLE ADD COLUMN 等常见迁移语句）
- [ ] 支持读取 `.pgorm/schema.json`
- [ ] （可选）从 DB 刷新/生成 schema cache

### SQL 解析与推导（MVP）

- [ ] 解析 `$n` 参数，生成签名（顺序、命名、可 override）
- [ ] SELECT 列类型推导（简单列引用 + 可空）
- [ ] LEFT JOIN 可空传播（基础版）
- [ ] 推导失败的报错与提示（cast / override）

### 代码生成

- [ ] 按 queries 文件生成模块
- [ ] 生成 `mod.rs` 聚合
- [ ] 生成 `Queries<'a, C>`（可配置关闭）
- [ ] 生成 Row/Params struct（derive 可配置）
- [ ] 可选 tagged 执行（tag = query name）

### 工程化

- [ ] `--check` 模式返回非 0（CI 友好）
- [ ] `--dry-run`（打印将生成的文件列表与摘要）
- [ ] 生成稳定性（排序、命名规则、最小 diff）
